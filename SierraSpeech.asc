// new module script
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * SPEECH BUBBLE MODULE - Script                                                           *
 * by Gunnar Harboe (Snarky), v0.8.0                                                       *
 *                                                                                         *
 * Copyright (c) 2017 Gunnar Harboe                                                        *
 *                                                                                         *
 * This code is offered under the MIT License                                              *
 * https://opensource.org/licenses/MIT                                                     *
 *                                                                                         *
 * It is also licensed under a Creative Commons Attribution 4.0 International License.     *
 * https://creativecommons.org/licenses/by/4.0/                                            *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
FontType fontWithoutOutline(FontType fontname){
  if(fontname == eFontSpeech){
    return eFontFontSpeechWOOutline;
  } else {
    return fontname;  
  }
}


//Things to make the portrait adjustment work
int Portrait_Sierra_Y;
int Portrait_Left_Indent;
int Portrait_Right_Indent;
bool Portrait_AtRight;
Character * Portrait_Last_Talker;
GUI * Portrait_GUI;
int Portrait_View;
int Portrait_Loop;
int Portrait_Frame;
int Portrait_Counter;
DynamicSprite *Portrait_Mod;
ViewFrame *Portrait_vf;
int Portrait_AnimSpeed;
int Portrait_BlinkTimer;
int Portrait_BlinkView;
int Portrait_BlinkLoop;
int Portrait_BlinkFrame;
int Portrait_BlinkInterval;
bool Portrait_AutoFlip;
int positioning;



function Portrait_DoFrame() {
    Portrait_vf=Game.GetViewFrame(Portrait_View,  Portrait_Loop, Portrait_Frame);
    bool flip=Portrait_vf.Flipped;
    // Something like:
    if (Portrait_AutoFlip && Portrait_AtRight) flip=!flip;
    Portrait_Mod=DynamicSprite.CreateFromExistingSprite(Portrait_vf.Graphic, true);
    if (Portrait_BlinkTimer==0) {
      DrawingSurface *mod=Portrait_Mod.GetDrawingSurface();
      ViewFrame *bvf=Game.GetViewFrame(Portrait_BlinkView,  Portrait_BlinkLoop, Portrait_BlinkFrame);
      mod.DrawImage(0, 0, bvf.Graphic);
      mod.Release();
      Portrait_BlinkFrame++;
      if (Portrait_BlinkFrame==Game.GetFrameCountForLoop(Portrait_BlinkView,  Portrait_BlinkLoop)) {
        Portrait_BlinkTimer=Portrait_BlinkInterval;
        Portrait_BlinkFrame=0;
      }
    }
    // Flip AFTER blink, if required
    if (flip) Portrait_Mod.Flip(eFlipLeftToRight);
    Portrait_GUI.BackgroundGraphic=Portrait_Mod.Graphic;
}

void PortraitSay_Before(Character * acharacter) {
  int view = -1;
  int loop = 0;
  if (view<1) view=acharacter.SpeechView;
  Portrait_Frame=0;
  Portrait_Loop=loop;
  Portrait_View=view;
  Portrait_AnimSpeed=acharacter.AnimationSpeed;
  positioning=GetGameOption(OPT_PORTRAITPOSITION);
  int x;
  if (positioning==0) { //Left
    Portrait_AtRight=false;
  } else if (positioning==1) { //Right
    Portrait_AtRight=true;
  } else if (positioning==2) { //Alternate
    if (acharacter!=Portrait_Last_Talker) Portrait_AtRight=!Portrait_AtRight;
  } else { // X positioning
    if (Portrait_Last_Talker != null && acharacter!=Portrait_Last_Talker) {
      Portrait_AtRight=acharacter.x>Portrait_Last_Talker.x;
    } else {
      // Cunning algorithm that one might prefer: count how many people
      // are on each side of us...
      //int side;
      //int j=0;
      //while (j<Game.CharacterCount) {
      //  if (character[j].Room==player.Room) {
      //    if (character[j].x<player.x) side++;
      //    else if (character[j].x>player.x) side--;
      //	}
      //	j++;
      //}
      //if (side>0) Portrait_AtRight=true;
      //else if (side<0) Portrait_AtRight=false;
      //else {
      //  if (acharacter!=Portrait_Last_Talker) Portrait_AtRight=!Portrait_AtRight;
      //}
      
      if (Portrait_Last_Talker != null && acharacter==Portrait_Last_Talker) {
        //Portrait_AtRight=!Portrait_AtRight;
      } else {
        if (acharacter.x<(System.ViewportWidth/2)) Portrait_AtRight=false;
        else Portrait_AtRight=true;
      }

    }
  }

  Portrait_Last_Talker = acharacter;
  Portrait_DoFrame();

  if (Portrait_AtRight) {
    x=System.ViewportWidth-Game.SpriteWidth[Portrait_vf.Graphic]-Portrait_Right_Indent;
  } else {
    x=Portrait_Left_Indent;
  }

  Portrait_GUI.X=x;
  Portrait_GUI.Y=Portrait_Sierra_Y;
  SetGameOption(OPT_PORTRAITPOSITION, Portrait_AtRight);
  Portrait_GUI.Visible=true;
  Portrait_Counter=Portrait_AnimSpeed+Portrait_vf.Speed+1;
  if (acharacter.BlinkView>0) {
    Portrait_BlinkTimer=acharacter.BlinkInterval;
    Portrait_BlinkInterval=acharacter.BlinkInterval;
    Portrait_BlinkView=acharacter.BlinkView;
    Portrait_BlinkLoop=0;
    Portrait_BlinkFrame=0;
  }

  else Portrait_BlinkTimer=-1;
}

void PortraitSay_After(){
  Portrait_GUI.Visible=false;
  SetGameOption(OPT_PORTRAITPOSITION, positioning);
  Portrait_Counter=-1;
  Portrait_BlinkTimer=-1;
}

// Change this function to call a different Say() function
void SB_sayImpl(this Character*, String message)
{
  this.Say(message);
}

// If you want to use another function to animate background speech (e.g. to do lip-sync),
// call it here and return true
bool SB_sayBackgroundAnimateImpl(this Character*, String message)
{
  return false;
}

// If you're using another function to animate background speech, replace this with the
// appropriate test to see if the background speech animation is running
/*
bool SB_isSpeakingBackground(this Character*)
{
  SpeechBubble* sb = this.GetSpeechBubble();
  return (sb != null && sb.IsBackgroundSpeech);
}*/

#region Block functions
#define eMouseNone 0

enum BlockEndType
{
  eBlockTimeOut,
  eBlockKeyInterrupt,
  eBlockMouseInterrupt,
  eBlockUnknownInterrupt
};

//#define MAX_WAIT 32767
#define MAX_WAIT 20

#define CTRL_OFFSET 64
#define ALT_OFFSET (-236)
#define CTRL_RANGE_START 1
#define CTRL_RANGE_END 26
#define ALT_RANGE_START 301
#define ALT_RANGE_END 326
#define MAX_KEYCODE 435

#define eKeyLeftShift 403
#define eKeyRightShift 404
#define eKeyLeftCtrl 405
#define eKeyRightCtrl 406
#define eKeyLeftAlt 407
#define eKeyRightAlt 420

int _waitLoops;
eKeyCode _interruptKey;
MouseButton _interruptButton;

bool _wasButtonDown;
bool _wasKeyDown;

int _maxInt(int a, int b)
{
  if(a>b) return a;
  return b;
}

int _minInt(int a, int b)
{
  if(a<b) return a;
  return b;
}

bool IsButtonDownAny(static Mouse)
{
  return Mouse.IsButtonDown(eMouseLeft) || Mouse.IsButtonDown(eMouseRight) || Mouse.IsButtonDown(eMouseMiddle);
}

bool IsKeyPressedCombi(eKeyCode keyCode)
{
  if(keyCode >= CTRL_RANGE_START && keyCode <= CTRL_RANGE_END)
  {
    return (IsKeyPressed(eKeyLeftCtrl) || IsKeyPressed(eKeyRightCtrl)) && IsKeyPressed(keyCode+CTRL_OFFSET);
  }
  else if(keyCode >= ALT_RANGE_START && keyCode <= ALT_RANGE_END)
  {
    return (IsKeyPressed(eKeyLeftAlt) || IsKeyPressed(eKeyRightAlt)) && IsKeyPressed(keyCode+ALT_OFFSET);
  }
  else
    return IsKeyPressed(keyCode);
}

bool IsModifier(eKeyCode keyCode)
{
  return (keyCode == eKeyLeftShift || keyCode == eKeyRightShift ||
          keyCode == eKeyLeftCtrl  || keyCode == eKeyRightCtrl  ||
          keyCode == eKeyLeftAlt   || keyCode == eKeyRightAlt);
}

eKeyCode GetKeyPressed()
{
  for(int i=1; i<MAX_KEYCODE; i++)
  {
    if(!IsModifier(i) && IsKeyPressed(i))
      return i;
  }
  return 0;
}

bool IsKeyPressedAny()
{
  return (GetKeyPressed() != 0);
}

bool CheckKey(eKeyCode keyCode)
{
  if(keyCode == eKeyNone)
    return IsKeyPressedAny();
  else
    return IsKeyPressedCombi(keyCode);
}

bool CheckMouse(MouseButton button)
{
  if(button == eMouseNone)
    return Mouse.IsButtonDownAny();
  else
    return Mouse.IsButtonDown(button);
}

BlockEndType EndBlock(BlockEndType endType)
{
  _waitLoops = 0;
  _wasButtonDown = false;
  _wasKeyDown = false;
  return endType;
}

BlockEndType Block(int loops)
{
  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    Wait(_waitLoops);
  }
  return eBlockTimeOut;
}

BlockEndType BlockKey(int loops, eKeyCode keyCode)
{
  _interruptKey = keyCode;
  if(loops<0)
  {
    // Keep waiting indefinitely until the WaitKey() was interrupted
    while(true)
    {
      _waitLoops = MAX_WAIT;
      WaitKey(MAX_WAIT);
      // If the wrong key, ignore the interruption
      if((keyCode == eKeyNone && _waitLoops != 0) || IsKeyPressedCombi(keyCode) || _wasKeyDown)
        return EndBlock(eBlockKeyInterrupt);
    }
  }

  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    WaitKey(_waitLoops);
    if((keyCode == eKeyNone && _waitLoops != 0) || IsKeyPressedCombi(keyCode) || _wasKeyDown)
      return EndBlock(eBlockKeyInterrupt);
    loops += _waitLoops;
  }
  return EndBlock(eBlockTimeOut);
}

BlockEndType BlockMouse(int loops, MouseButton button)
{
  _interruptButton = button;
  if(loops<0)
  {
    while(true)
    {
      _waitLoops = MAX_WAIT;
      WaitMouseKey(MAX_WAIT);
      if(CheckMouse(button) || _wasButtonDown)
        return EndBlock(eBlockMouseInterrupt);
    }
  }

  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    WaitMouseKey(_waitLoops);
    if(CheckMouse(button) || _wasButtonDown)
      return EndBlock(eBlockMouseInterrupt);
    loops += _waitLoops;
  }
  return EndBlock(eBlockTimeOut);
}

BlockEndType BlockMouseKey(int loops, eKeyCode keyCode, MouseButton button)
{
  _interruptKey = keyCode;
  _interruptButton = button;
  if(loops<0)
  {
    // Keep waiting indefinitely until the WaitKey() was interrupted
    while(true)
    {
      _waitLoops = MAX_WAIT;
      WaitMouseKey(MAX_WAIT);
      if(CheckMouse(button) || _wasButtonDown)
        return EndBlock(eBlockMouseInterrupt);
      if(CheckKey(keyCode) || _wasKeyDown)
        return EndBlock(eBlockKeyInterrupt);
      // Fallback if we can't identify what was pressed, but it doesn't matter
      if(_waitLoops != 0 && button == eMouseNone && keyCode == eKeyNone)
        return EndBlock(eBlockUnknownInterrupt);
    }
  }

  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    WaitMouseKey(_waitLoops);
    if(CheckMouse(button) || _wasButtonDown)
      return EndBlock(eBlockMouseInterrupt);
    if(CheckKey(keyCode) || _wasKeyDown)
      return EndBlock(eBlockKeyInterrupt);
    // Fallback if we can't identify what was pressed, but it doesn't matter
    if(_waitLoops != 0 && button == eMouseNone && keyCode == eKeyNone)
      return EndBlock(eBlockUnknownInterrupt);
    loops += _waitLoops;
  }
  return EndBlock(eBlockTimeOut);
}

BlockEndType BlockSpeech(int loops, bool forceTimeOut)
{
  switch(Speech.SkipStyle)
  {
    case eSkipKey:
      if(forceTimeOut)
        return BlockKey(loops, Speech.SkipKey);
      else
        return BlockKey(-1, Speech.SkipKey);
    case eSkipKeyMouse:
      if(forceTimeOut)
        return BlockMouseKey(loops, Speech.SkipKey, eMouseNone);
      else
        return BlockMouseKey(-1, Speech.SkipKey, eMouseNone);
    case eSkipKeyMouseTime:
      return BlockMouseKey(loops, Speech.SkipKey, eMouseNone);
    case eSkipKeyTime:
      return BlockKey(loops, Speech.SkipKey);
    case eSkipMouse:
      if(forceTimeOut)
        return BlockMouse(loops, eMouseNone);
      else
        return BlockMouse(-1, eMouseNone);
    case eSkipMouseTime:
      return BlockMouse(loops, eMouseNone);
    case -1: // In AGS 3.4.0, Speech.SkipStyle reports -1 instead of eSkipTime(==2) when set to that value
    case eSkipTime:
      return Block(loops);
  }
}

// called from repeatedly_execute_always()
function _block_always()
{
  if(_waitLoops != 0)
  {
    _wasButtonDown = CheckMouse(_interruptButton);
    _wasKeyDown = CheckKey(_interruptKey);
  }
  if(_waitLoops > 0)
    _waitLoops--;
}

#endregion

#region Variable declarations
// Variables for the SpeecBubble attributes
GUI* _defaultGui;

int _textOutlineColor;
int _textOutlineSpeechTint;
int _textOutlineWidth;
TextOutlineStyle _textOutlineStyle;

int _maxTextWidth;
int _heightOverHead;
int _paddingTop;
int _paddingBottom;
int _paddingLeft;
int _paddingRight;

GUI* _bubbleGui;
FontType _invisibleFont;
Alignment _textAlign;

// Internal script variables
Character* _bubbleChars[];
SpeechBubble* _charBubbles[];  // Array to store bubbles for all characters
String _bubbleMessages[];
DynamicSprite* _bubbleSprites[];
GUI* _bubbleGuis[];
int _bubbleCount;

#endregion

// Helper functions

int _clampInt(int value, int minRange, int maxRange)
{
  if(value<minRange) return minRange;
  if(value>maxRange) return maxRange;
  return value;
}

// Calculate the color that comes closest to a mix of c1 and c2 (at 'mix' percent c1)
int mixColors(int c1, int c2, int mix)
{
  if(mix==0) return c2;
  if(mix==100) return c1;
  int r1, g1, b1;
  int r2, g2, b2;

  // Extract the c1 channels
  if(c1 < 32)
  {
    r1 = (palette[c1].r << 2) + (palette[c1].r >> 4);
    g1 = (palette[c1].g << 2) + (palette[c1].g >> 4);
    b1 = (palette[c1].b << 2) + (palette[c1].b >> 4);
  }
  else
  {
    r1 = (c1 & 63488) >> 11; // 63488 = binary 11111-000000-00000
    g1 = (c1 & 2016) >> 5;   //  2016 = binary 00000-111111-00000
    b1 = (c1 & 31);          //    31 = binary 00000-000000-11111

    r1 = (r1 << 3) + (r1 >> 2);
    g1 = (g1 << 2) + (g1 >> 4);
    b1 = (b1 << 3) + (b1 >> 2);
  }

  // Extract the c2 channels
  if(c2 < 32)
  {
    r2 = (palette[c2].r << 2) + (palette[c2].r >> 4);
    g2 = (palette[c2].g << 2) + (palette[c2].g >> 4);
    b2 = (palette[c2].b << 2) + (palette[c2].b >> 4);
  }
  else
  {
    r2 = (c2 & 63488) >> 11; // 63488 = binary 11111-000000-00000
    g2 = (c2 & 2016) >> 5;   //  2016 = binary 00000-111111-00000
    b2 = (c2 & 31);          //    31 = binary 00000-000000-11111

    r2 = (r2 << 3) + (r2 >> 2);
    g2 = (g2 << 2) + (g2 >> 4);
    b2 = (b2 << 3) + (b2 >> 2);
  }

  // Calculate the mix
  int r = (r1 * mix + r2*(100-mix) + 50) / 100; // +50 to round up to nearest
  int g = (g1 * mix + g2*(100-mix) + 50) / 100;
  int b = (b1 * mix + b2*(100-mix) + 50) / 100;

  // Convert back to AGS color num
  r = r >> 3;
  g = g >> 2;
  b = b >> 3;

  r = r << 11;
  g = g << 5;

  int c = r+g+b;
  if(c < 32)
    c += 65536;
  return c;
}

// Attribute accessors
#region SpeechBubble Attribute accessors

#region static accessors
GUI* get_DefaultGui(static SpeechBubble)
{ return _defaultGui; }
void set_DefaultGui(static SpeechBubble, GUI* value)
{ _defaultGui = value; }

int get_TextOutlineColor(static SpeechBubble)
{ return _textOutlineColor; }
void set_TextOutlineColor(static SpeechBubble, int value)
{ _textOutlineColor = value; }

int get_TextOutlineSpeechTint(static SpeechBubble)
{ return _textOutlineSpeechTint; }
void set_TextOutlineSpeechTint(static SpeechBubble, int value)
{ _textOutlineSpeechTint = _clampInt(value, 0, 100); }

int get_TextOutlineWidth(static SpeechBubble)
{ return _textOutlineWidth; }
void set_TextOutlineWidth(static SpeechBubble, int value)
{ _textOutlineWidth = value; }

TextOutlineStyle get_TextOutlineStyle(static SpeechBubble)
{ return _textOutlineStyle; }
void set_TextOutlineStyle(static SpeechBubble, TextOutlineStyle value)
{ _textOutlineStyle = value; }

int get_MaxTextWidth(static SpeechBubble)
{ return _maxTextWidth; }
void set_MaxTextWidth(static SpeechBubble, int value)
{ _maxTextWidth = value; }

int get_HeightOverHead(static SpeechBubble)
{ return _heightOverHead; }
void set_HeightOverHead(static SpeechBubble, int value)
{ _heightOverHead = value; }

int get_PaddingTop(static SpeechBubble)
{ return _paddingTop; }
void set_PaddingTop(static SpeechBubble, int value)
{ _paddingTop = value; }

int get_PaddingBottom(static SpeechBubble)
{ return _paddingBottom; }
void set_PaddingBottom(static SpeechBubble, int value)
{ _paddingBottom = value; }

int get_PaddingLeft(static SpeechBubble)
{ return _paddingLeft; }
void set_PaddingLeft(static SpeechBubble, int value)
{ _paddingLeft = value; }

int get_PaddingRight(static SpeechBubble)
{ return _paddingRight; }
void set_PaddingRight(static SpeechBubble, int value)
{ _paddingRight = value; }


FontType get_InvisibleFont(static SpeechBubble)
{ return _invisibleFont; }
void set_InvisibleFont(static SpeechBubble, FontType value)
{ _invisibleFont = value; }

Alignment get_TextAlign(static SpeechBubble)
{ return _textAlign; }
void set_TextAlign(static SpeechBubble, Alignment value)
{ _textAlign = value; }
#endregion

#region instance accessors
Character* get_OwningCharacter(this SpeechBubble*)
{
  if(this._id == -1) return null;
  else return character[this._id];
}

bool get_Valid(this SpeechBubble*)
{ return this._valid; }
bool get_IsBackgroundSpeech(this SpeechBubble*)
{ return this._isBackgroundSpeech; }
bool get_IsThinking(this SpeechBubble*)
{ return this._isThinking; }
bool get_IsAnimating(this SpeechBubble*)
{ return this._isAnimating; }
String get_Text(this SpeechBubble*)
{ return _bubbleMessages[this._id]; }
DynamicSprite* get_BubbleSprite(this SpeechBubble*)
{ return _bubbleSprites[this._id]; }
GUI* get_BubbleGUI(this SpeechBubble*)
{ return _bubbleGuis[this._id]; }
int get_TotalDuration(this SpeechBubble*)
{ return this._totalDuration; }
int get_ElapsedDuration(this SpeechBubble*)
{ return this._elapsedDuration; }

int get_X(this SpeechBubble*)
{ return this._x; }
void set_X(this SpeechBubble*, int value)
{
  this._x = value;
  if(!this._valid) return;

  GUI* g = this.get_BubbleGUI();
  g.X = value;

}

int get_Y(this SpeechBubble*)
{ return this._y; }
int set_Y(this SpeechBubble*, int value)
{
  this._y = value;
  if(!this._valid) return;

  GUI* g = this.get_BubbleGUI();
  g.Y = value;

}

#endregion

// "Protected" setters: used internally to setup SpeechBubble instances
void setOwningCharacter(this SpeechBubble*, Character* value)
{
  if(value == null)
    this._id = -1;
  else
    this._id = value.ID;
}
void setValid(this SpeechBubble*, bool value)
{ this._valid = value; }
void setBackgroundSpeech(this SpeechBubble*, bool value)
{ this._isBackgroundSpeech = value; }
void setThinking(this SpeechBubble*, bool value)
{ this._isThinking = value; }
void setAnimating(this SpeechBubble*, bool value)
{ this._isAnimating = value; }
void setTotalDuration(this SpeechBubble*, int value)
{ this._totalDuration = value; }
void setElapsedDuration(this SpeechBubble*, int value)
{ this._elapsedDuration = value; }
void setX(this SpeechBubble*, int value)
{ this._x = value; }
void setY(this SpeechBubble*, int value)
{ this._y = value; }

SpeechBubble* Create(static SpeechBubble, Character* owner, String message, DynamicSprite* bubbleSprite, GUI* bubbleGui)
{
  SpeechBubble* sb = new SpeechBubble;
  sb.setOwningCharacter(owner);
  sb.setValid(true);
  int id = owner.ID;
  _charBubbles[id] = sb;
  _bubbleMessages[id] = message;
  _bubbleSprites[id] = bubbleSprite;
  _bubbleGuis[id] = bubbleGui;
  return sb;
}

void _addBubbleChar(Character* c)
{
  _bubbleChars[_bubbleCount] = c;
  _bubbleCount++;
}

bool _removeBubbleChar(Character* c)
{
  if(c == null)
    return false;
  for(int i=0; i<_bubbleCount; i++)
  {
    if(_bubbleChars[i] == c)
    {
      _bubbleCount--;
      _bubbleChars[i] = _bubbleChars[_bubbleCount];
      _bubbleChars[_bubbleCount] = null;
      return true;
    }
  }
  return false;
}

void Remove(this SpeechBubble*)
{
  SpeechBubble* _this = this;
  int id = this._id;
  if(id != -1)
  {
    _removeBubbleChar(this.get_OwningCharacter());

    _charBubbles[id] = null;
    _bubbleMessages[id] = null;
    if(_bubbleSprites[id] != null)
      _bubbleSprites[id].Delete();
    _bubbleSprites[id] = null;
    if(_bubbleGuis[id] != null)
      _bubbleGuis[id].Visible = false;
    _bubbleGuis[id] = null;
  }
  this._valid = false;
}


#endregion

// Calculate the height of the character at current scaling (due to rounding, believe this could be 1 pixel off)
int GetHeight(this Character*)
{
  ViewFrame* frame = Game.GetViewFrame(this.View, this.Loop, this.Frame);
  // TODO: Check that Z value is correctly calculated
  return ((Game.SpriteHeight[frame.Graphic] + this.z) * this.Scaling)/100;
}

// Whether the character is speaking in a speech bubble (if includeBackground, count background speech as speech)
bool IsSpeakingBubble(this Character*, bool includeBackground)
{
  SpeechBubble* bubble = _charBubbles[this.ID];
  return (bubble != null && (includeBackground || !bubble.get_IsBackgroundSpeech()));
}

/// Interrupt the character if they are speaking in the background
bool StopBackgroundBubble(this Character*)
{
  SpeechBubble* bubble = _charBubbles[this.ID];
  if(bubble != null && bubble.get_Valid() && bubble.get_IsBackgroundSpeech())
  {
    if(bubble.get_IsAnimating())
      this.UnlockView();
    bubble.Remove();
    return true;
  }
  return false;
}

void _stopAllBackgroundBubbles()
{
  for(int i=_bubbleCount-1; i >= 0; i--)
  {
    int id = _bubbleChars[i].ID;
    if(_charBubbles[id].get_IsBackgroundSpeech())
      _bubbleChars[i].StopBackgroundBubble();
  }
}

/// The speech bubble used by the character (null if none)
SpeechBubble* GetSpeechBubble(this Character*)
{
  return _charBubbles[this.ID];
}

// Initializations
void initSpeechBubble()
{
  // Initialize arrays
  _bubbleChars = new Character[Game.CharacterCount];
  _charBubbles = new SpeechBubble[Game.CharacterCount];
  _bubbleMessages = new String[Game.CharacterCount];
  _bubbleSprites = new DynamicSprite[Game.CharacterCount];
  _bubbleGuis = new GUI[Game.CharacterCount];

  // Set default values
  SpeechBubble.set_InvisibleFont(-1);
  SpeechBubble.set_TextAlign(eAlignCentre);

  SpeechBubble.set_MaxTextWidth(-1);
  SpeechBubble.set_TextOutlineColor(33);
  SpeechBubble.set_TextOutlineSpeechTint(10);
  SpeechBubble.set_TextOutlineWidth(1);
  SpeechBubble.set_TextOutlineStyle(eTextOutlineSquare);
  //SpeechBubble.set_PaddingTop(10);
  //SpeechBubble.set_PaddingBottom(10);
  //SpeechBubble.set_PaddingLeft(20);
  //SpeechBubble.set_PaddingRight(20);

  SpeechBubble.set_PaddingTop(6);
  SpeechBubble.set_PaddingBottom(6);
  SpeechBubble.set_PaddingLeft(6);
  SpeechBubble.set_PaddingRight(6);

  SpeechBubble.set_DefaultGui(gMySierraTextBox);
}

function game_start()
{
  //stuff for portrait module
  gPortrait.Visible=false;
  Portrait_Sierra_Y=20; // Guess, seems lucky!
  Portrait_Left_Indent=10; // Trial and error
  Portrait_Right_Indent=5; // Trial and error
  Portrait_Counter=-1;
  Portrait_BlinkTimer=-1;
  Portrait_GUI=gPortrait;
  initSpeechBubble();
}

// To work around the AGS bug where antialiasing "pokes holes" in semi-transparent canvases
void drawStringWrappedAA(this DrawingSurface*, int x, int y, int width, FontType font, Alignment alignment, String message)
{
  DynamicSprite* textSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* textSurface = textSprite.GetDrawingSurface();
  textSurface.DrawingColor = this.DrawingColor;
  textSurface.DrawStringWrapped(x, y, width, font, alignment, message);
  textSurface.Release();
  this.DrawImage(0, 0, textSprite.Graphic);
  textSprite.Delete();
}

// Draw a string with outline (make sure the canvas has at least outlineWidth pixels on each side of the string)
void drawStringWrappedOutline(this DrawingSurface*, int x, int y, int width, TextOutlineStyle outlineStyle, FontType font,  Alignment alignment, String message, int outlineColor, int outlineWidth)
{
  // This is what we draw on (because we might need to copy with transparency)
  DynamicSprite* outlineSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* outlineSurface = outlineSprite.GetDrawingSurface();

  // This holds multiple horizontal copies of the text
  // We copy it multiple times (shifted vertically) onto the outlineSprite to create the outline
  DynamicSprite* outlineStripSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* outlineStripSurface = outlineStripSprite.GetDrawingSurface();

  // This is our "text stamp" that we use to draw the outline, we copy it onto outlineStripSprite
  DynamicSprite* textSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* textSurface = textSprite.GetDrawingSurface();

  // Draw our text stamp
  textSurface.DrawingColor = outlineColor;
  textSurface.DrawStringWrapped(x, y, width, font, alignment, message);
  textSurface.Release();

  switch(outlineStyle)
  {
    case eTextOutlineRounded:
    {
      // Draw Circular outline
      int maxSquare = outlineWidth*outlineWidth+1; // Add 1 for rounding purposes, to avoid "pointy corners"
      int maxWidth = 0;
      outlineStripSurface.DrawImage(0, 0, textSprite.Graphic);
      // We loop from top and bottom to the middle, making the outline wider and wider, to form circular outline
      for(int i = outlineWidth; i > 0; i--)
      {
        // Here's the circular calculation...
        while(i*i + maxWidth*maxWidth <= maxSquare)
        {
          // Increase width of the outline if necessary
          maxWidth++;
          outlineStripSurface.DrawImage(-maxWidth, 0, textSprite.Graphic);
          outlineStripSurface.DrawImage(maxWidth, 0, textSprite.Graphic);
          outlineStripSurface.Release();
          outlineStripSurface = outlineStripSprite.GetDrawingSurface();
        }
        // Draw outline strip above and below
        outlineSurface.DrawImage(0, -i, outlineStripSprite.Graphic);
        outlineSurface.DrawImage(0, i, outlineStripSprite.Graphic);
      }
      // Finally the middle strip
      outlineSurface.DrawImage(0, 0, outlineStripSprite.Graphic);
      break;
    }
    case eTextOutlineSquare:
    {
      // Draw square block outline
      // Just draw the full outline width onto the strip
      for(int i = -outlineWidth; i <= outlineWidth; i++)
        outlineStripSurface.DrawImage(i, 0, textSprite.Graphic);
      outlineStripSurface.Release();
      // Draw the full outline height
      for(int j = -outlineWidth; j <= outlineWidth; j++)
        outlineSurface.DrawImage(0, j, outlineStripSprite.Graphic);
      break;
    }
  }
  textSprite.Delete();
  outlineStripSurface.Release();
  outlineStripSprite.Delete();

  /// Now draw the text itself on top of the outline
  outlineSurface.DrawingColor = this.DrawingColor;
  outlineSurface.drawStringWrappedAA(x, y, width, font, alignment, message);
  outlineSurface.Release();
  // ... And copy it onto our canvas
  this.DrawImage(0, 0, outlineSprite.Graphic);
  outlineSprite.Delete();
}

// Find the actual width of a text that has been linewrapped to maxTextWidth
int calculateExactTextWidth(String message, FontType font, int maxTextWidth, int maxHeight)
{
  // Binary search to find the minimum width, by trying the midpoint (rounding down)
  // between the smallest width we know to be working and the biggest we know to be too small,
  // until there's only a 1 pixel difference
  int cut = maxTextWidth;
  int height = maxHeight;
  while(cut>1)
  {
    cut = (cut+1) >> 1; // Subtract half as much as we tried last time, rounding up
    height = GetTextHeight(message, font, maxTextWidth-cut);
    if(height == maxHeight)
      maxTextWidth -= cut;
  }
  // ... one last time
  height = GetTextHeight(message, font, maxTextWidth-1);
  if(height == maxHeight)
    return maxTextWidth-1;
  else
    return maxTextWidth;
}

// AGS's formula for character speech width
int calculateDefaultTextWidth(Character* c)
{
  int w;
  ViewFrame * vf;
  if(c.SpeechView > 0){
    vf = Game.GetViewFrame(c.SpeechView, 0, 0);
  }

  if( vf == null){
    w = System.ViewportWidth-Portrait_Left_Indent-Portrait_Right_Indent;
  } else {
    w = System.ViewportWidth-Game.SpriteWidth[vf.Graphic]-Portrait_Left_Indent-Portrait_Right_Indent;
  }

  return w;
}

// Draw a speech bubble in 32-bit (using transparency)
DynamicSprite* renderBubble32(this Character*, String message, bool talkTail)
{
  ViewFrame * vf;
  if(this.SpeechView > 0){
    vf = Game.GetViewFrame(this.SpeechView, 0, 0);
  }

  // Calculate text dimensions
  int textWidth = _maxTextWidth;
  if(textWidth <= 0)
    textWidth = calculateDefaultTextWidth(this);
  textWidth = _minInt(textWidth, System.ViewportWidth - _paddingLeft - _paddingRight-Game.SpriteWidth[vf.Graphic]-Portrait_Left_Indent-Portrait_Right_Indent);
  int textHeight = GetTextHeight(message, fontWithoutOutline(Game.SpeechFont), textWidth);
  textWidth = calculateExactTextWidth(message, fontWithoutOutline(Game.SpeechFont), textWidth, textHeight);

  // Calculate bubble dimensions
  int totalWidth = textWidth + _paddingLeft + _paddingRight;
  int bubbleHeight = textHeight + _paddingTop + _paddingBottom;


  // Set up the canvases
  DynamicSprite* bubbleSprite = DynamicSprite.Create(totalWidth, bubbleHeight, true);
  DrawingSurface* bubbleSurface = bubbleSprite.GetDrawingSurface();
  //bubbleSurface.Clear();

  //draw background
  bubbleSurface.DrawImage(Game.SpriteWidth[gTextGui_Edge0.NormalGraphic], Game.SpriteHeight[gTextGui_Edge0.NormalGraphic],
                      gTextGui.BackgroundGraphic, 0,
                      totalWidth-Game.SpriteWidth[gTextGui_Edge0.NormalGraphic]-Game.SpriteWidth[gTextGui_Edge3.NormalGraphic], bubbleHeight-Game.SpriteHeight[gTextGui_Edge0.NormalGraphic]-Game.SpriteHeight[gTextGui_Edge3.NormalGraphic]);

  // Top Left Corner
  bubbleSurface.DrawImage(0, 0, gTextGui_Edge0.NormalGraphic);


  // Top Right Corner
  bubbleSurface.DrawImage(totalWidth-Game.SpriteWidth[gTextGui_Edge2.NormalGraphic], 0, gTextGui_Edge2.NormalGraphic);


  // Bottom Left Corner
  bubbleSurface.DrawImage(0, bubbleHeight-Game.SpriteHeight[gTextGui_Edge1.NormalGraphic],  gTextGui_Edge1.NormalGraphic);


  // Bottom Right Corner
  bubbleSurface.DrawImage(totalWidth-Game.SpriteWidth[gTextGui_Edge3.NormalGraphic], bubbleHeight-Game.SpriteHeight[gTextGui_Edge3.NormalGraphic], gTextGui_Edge3.NormalGraphic);

  // Top Edge
  bubbleSurface.DrawImage(Game.SpriteWidth[gTextGui_Edge0.NormalGraphic], 0,
                      gTextGui_Edge6.NormalGraphic, 0,
                      totalWidth-Game.SpriteWidth[gTextGui_Edge0.NormalGraphic]-Game.SpriteWidth[gTextGui_Edge2.NormalGraphic], Game.SpriteHeight[gTextGui_Edge6.NormalGraphic]);
  // Left Edge
  bubbleSurface.DrawImage(0, Game.SpriteHeight[gTextGui_Edge0.NormalGraphic],
                      gTextGui_Edge4.NormalGraphic, 0,
                      Game.SpriteWidth[gTextGui_Edge4.NormalGraphic], bubbleHeight-Game.SpriteHeight[gTextGui_Edge0.NormalGraphic]-Game.SpriteHeight[gTextGui_Edge1.NormalGraphic]);
  // Right Edge
  bubbleSurface.DrawImage(totalWidth-Game.SpriteWidth[gTextGui_Edge5.NormalGraphic], Game.SpriteHeight[gTextGui_Edge2.NormalGraphic],
                      gTextGui_Edge5.NormalGraphic, 0,
                      Game.SpriteWidth[gTextGui_Edge5.NormalGraphic], bubbleHeight-Game.SpriteHeight[gTextGui_Edge2.NormalGraphic]-Game.SpriteHeight[gTextGui_Edge3.NormalGraphic]);

  // Bottom Edge
  bubbleSurface.DrawImage(Game.SpriteWidth[gTextGui_Edge1.NormalGraphic], bubbleHeight-Game.SpriteHeight[gTextGui_Edge7.NormalGraphic],
                      gTextGui_Edge7.NormalGraphic, 0,
                      totalWidth-Game.SpriteWidth[gTextGui_Edge1.NormalGraphic]-Game.SpriteWidth[gTextGui_Edge3.NormalGraphic], Game.SpriteHeight[gTextGui_Edge7.NormalGraphic]);



  bubbleSurface.DrawingColor = this.SpeechColor;
  int outlineColor = mixColors(this.SpeechColor, _textOutlineColor, _textOutlineSpeechTint);
  if(_textOutlineWidth > 0)
    bubbleSurface.drawStringWrappedOutline(_paddingLeft, _paddingTop, textWidth, _textOutlineStyle, fontWithoutOutline(Game.SpeechFont), _textAlign, message, outlineColor, _textOutlineWidth);
  else
    bubbleSurface.drawStringWrappedAA(_paddingLeft, _paddingTop, textWidth, fontWithoutOutline(Game.SpeechFont), _textAlign, message);

  bubbleSurface.Release();
  return bubbleSprite;
}

// Whether a speech string has a voice clip ID
bool hasVoiceClip(String message)
{
  return (message != null && message.Length>1 && message.Chars[0] == '&' && message.Chars[1] >= '0' && message.Chars[1] <= '9');
}

// Get the voice clip ID (speech line number) of a speech string, in the "&123" string format
String getLineNumber(String message)
{
  if(hasVoiceClip(message))
  {
    String s = message.Substring(1, message.Length-1);
    int n = s.AsInt;
    return String.Format("&%d", n);
  }
  return null;
}

int calculateDuration(String message)
{
  return _maxInt((Game.MinimumTextDisplayTimeMs * GetGameSpeed()) / 1000,
                ((message.Length / Game.TextReadingSpeed) + 1) * GetGameSpeed());
}

int calculateSpeechPause()
{
  return (Speech.DisplayPostTimeMs * GetGameSpeed())/1000;
}

// Run the character's speech animation and block for the appropriate time. Returns whether interrupted
// is actually doing the blocking and not animation
bool BlockForSpeech(this Character*, String message)
{
  int speechDuration = calculateDuration(message);
  if(BlockSpeech(speechDuration, true) == eBlockTimeOut)
  {
    int speechPause = calculateSpeechPause();
    return (BlockSpeech(speechPause, false) != eBlockTimeOut);
  }
  else
  {
    return false;
  }
}

void realSayAtBubble(this Character*, int x, int y, String message, GUI* bubbleGui, DynamicSprite* bubbleSprite)
{
  // Render and display the speech bubble
  if(bubbleSprite == null)
    bubbleSprite = this.renderBubble32(message, true);

  if(bubbleGui == null)
    bubbleGui = _defaultGui;

  bubbleGui.Clickable = false;
  bubbleGui.X = _clampInt(x, 0, System.ViewportWidth - bubbleSprite.Width);
  bubbleGui.Y = _clampInt(y, 0, System.ViewportHeight - bubbleSprite.Height);
  bubbleGui.Width = bubbleSprite.Width;
  bubbleGui.Height = bubbleSprite.Height;
  bubbleGui.BackgroundGraphic = bubbleSprite.Graphic;
  bubbleGui.Visible = true;

  SpeechBubble* bubble = SpeechBubble.Create(this, message, bubbleSprite, bubbleGui);

  bubble.setX(x);
  bubble.setY(y);
  bubble.setBackgroundSpeech(false);
  bubble.setThinking(false);
  _addBubbleChar(this);

  // Play speech (this chunk blocks until speech is complete)

  String lineNumber = getLineNumber(message);
  // If we have set an invisible font, just call Say() - or whatever custom Say() implementation we have
  if(SpeechBubble.get_InvisibleFont() != -1)
  {
    FontType speechFont = Game.SpeechFont;
    Game.SpeechFont = _invisibleFont;
    this.SB_sayImpl(message);
    Game.SpeechFont = speechFont;
  }
  // Else if we're going to play a voice clip, call Say() with the clip number and a blank line of text
  // (takes care of animation and doesn't display any text). This doesn't work with text-based lip-sync,
  // so if you're using text-based lip-sync, you MUST set an invisible font to get lip-sync to work
  else if(lineNumber != null && Speech.VoiceMode != eSpeechTextOnly) // && !GetGameOption(OPT_LIPSYNCTEXT))
  {
    String s = lineNumber;
    while(s.Length < message.Length)
      s = s.AppendChar(' ');
    this.SB_sayImpl(s);
  }
  // Otherwise we have to do it manually...
  else
  {
    bubble.setAnimating(true);
    this.BlockForSpeech(message);
  }

  // Remove the bubble
  bubble.Remove();
}

void SayBubble(this Character*, String message, GUI* bubbleGui)
{
  if(message == null) return;
  if(!game.bgspeech_stay_on_display)
    _stopAllBackgroundBubbles();
  if(bubbleGui == null){
    bubbleGui = _defaultGui;  
  }
  if((Speech.VoiceMode == eSpeechVoiceOnly && hasVoiceClip(message)) || message == "...")
    this.SB_sayImpl(message);
  else
  {
    PortraitSay_Before(this);
    DynamicSprite* bubbleSprite = this.renderBubble32(message, true);
    // Position bubble over character head
    int x = bubbleSprite.Width/2;
    if (Portrait_AtRight) {
      x=System.ViewportWidth-Game.SpriteWidth[Portrait_vf.Graphic]-Portrait_Right_Indent-bubbleSprite.Width;
    } else {
      x=Portrait_Left_Indent+Game.SpriteWidth[Portrait_vf.Graphic];
    }
    x = _clampInt(x, 0, System.ViewportWidth - bubbleSprite.Width);

    int y = Portrait_Sierra_Y;
    y = _clampInt(y, 0, System.ViewportHeight - bubbleSprite.Height);

    bubbleGui.Transparency = 80;
    bubbleGui.TweenTransparency(0.1, 0, eEaseLinearTween, eNoBlockTween);
    this.realSayAtBubble(x, y, message, bubbleGui, bubbleSprite);
    PortraitSay_After();
  }
}

void SayAtBubble(this Character*, int x, int y, String message, GUI* bubbleGui)
{
  if(message == null) return;
  if(bubbleGui == null){
    bubbleGui = _defaultGui;  
  }
  if(!game.bgspeech_stay_on_display)
    _stopAllBackgroundBubbles();
  if((Speech.VoiceMode == eSpeechVoiceOnly && hasVoiceClip(message)) || message == "...")
    this.SB_sayImpl(message);
  else {
    PortraitSay_Before(this);
    this.realSayAtBubble(x, y, message, bubbleGui, null);
    PortraitSay_After();
  }
}

SpeechBubble* SayBackgroundBubble(this Character*, String message, bool animate, GUI* bubbleGui)
{
  if(message == null)
    return null;
  if(bubbleGui == null){
    bubbleGui = _defaultGui;  
  }

  this.StopBackgroundBubble();
  DynamicSprite* bubbleSprite = this.renderBubble32(message, true);
  int x = this.x - GetViewportX() - bubbleSprite.Width/2;
  x = _clampInt(x, 0, System.ViewportWidth - bubbleSprite.Width);
  int y = this.y - GetViewportY() - bubbleSprite.Height - this.GetHeight() - (_heightOverHead + 1);
  y = _clampInt(y, 0, System.ViewportHeight - bubbleSprite.Height);

  bubbleGui.Clickable = false;
  bubbleGui.X = _clampInt(x, 0, System.ViewportWidth - bubbleSprite.Width);
  bubbleGui.Y = _clampInt(y, 0, System.ViewportHeight - bubbleSprite.Height);
  bubbleGui.Width = bubbleSprite.Width;
  bubbleGui.Height = bubbleSprite.Height;
  bubbleGui.BackgroundGraphic = bubbleSprite.Graphic;
  bubbleGui.Visible = true;

  SpeechBubble* bubble = SpeechBubble.Create(this, message, bubbleSprite, bubbleGui);
  bubble.setX(x);
  bubble.setY(y);
  bubble.setBackgroundSpeech(true);
  bubble.setThinking(false);
  bubble.setTotalDuration(calculateDuration(message));
  bubble.setAnimating(animate);

  // Add to stack of running Speech Bubbles to update
  _addBubbleChar(this);

  // The background speech is terminated in StopBackgroundBubble(), called from repeatedly_execute()
}

// TODO
void ThinkBubble(this Character*, String message, GUI* bubbleGui)
{
}

function repeatedly_execute()
{
  int speechPause = calculateSpeechPause();
  // Update the time elapsed on running bubbles, remove background bubbles that have timed out
  for(int i=0; i<_bubbleCount; i++)
  {
    int id = _bubbleChars[i].ID;
    _charBubbles[id].setElapsedDuration(_charBubbles[id].get_ElapsedDuration() + 1);
    if(_charBubbles[id].get_IsBackgroundSpeech() && _charBubbles[id].get_ElapsedDuration() > _charBubbles[id].get_TotalDuration())
    {
      // Add the post-display time
      if(speechPause > 0 && _charBubbles[id].get_IsAnimating())
      {
        _bubbleChars[i].UnlockView();
        _charBubbles[id].setAnimating(false);
        _charBubbles[id].setTotalDuration(speechPause);
        _charBubbles[id].setElapsedDuration(0);
      }
      else
        _bubbleChars[i].StopBackgroundBubble();
    }
  }
}

function repeatedly_execute_always()
{
  // portrait animation if needed
  if (Portrait_Counter==0) {
    Portrait_Frame++;
    if (Portrait_Frame==Game.GetFrameCountForLoop(Portrait_View, Portrait_Loop)) {
      Portrait_Frame=0;
    }
    Portrait_DoFrame();
    Portrait_Counter=Portrait_AnimSpeed+Portrait_vf.Speed+1;
  } else if (Portrait_Counter>=0) {
    Portrait_Counter--;
  }

  if (Portrait_BlinkTimer>0) {
    Portrait_BlinkTimer--;
  }
  //end of portrait animation if needed

  _block_always();
}

function on_event(EventType event, int Data){
  if(event == eEventLeaveRoom){
    if(gPortrait.Visible){
      PortraitSay_After();
    }  
    if(gMySierraTextBox.Visible){
      gMySierraTextBox.Visible = false;
    }
  }
} 
