// new module script
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * SIERRA SPEECH MODULE - Script                                                           *
 * forked from SPEECH BUBBLE MODULE - Script                                               *
 * by Gunnar Harboe (Snarky), v0.8.0                                                       *
 *                                                                                         *
 * Copyright (c) 2017 Gunnar Harboe                                                        *
 *                                                                                         *
 * This code is offered under the MIT License                                              *
 * https://opensource.org/licenses/MIT                                                     *
 *                                                                                         *
 * It is also licensed under a Creative Commons Attribution 4.0 International License.     *
 * https://creativecommons.org/licenses/by/4.0/                                            *
 *                                                                                         *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
FontType fontWithoutOutline(FontType fontname){
  // You can edit this if your speech font has outlines!
  //if(fontname == eFontSpeech){
  //  return eFontFontSpeechWOOutline;
  // } else {
    return fontname;
  //}
}

GUI * _defaultTextGUI;

//Things to make the portrait adjustment work
int Portrait_Sierra_Y;
int Portrait_Left_Indent;
int Portrait_Right_Indent;
bool Portrait_AtRight;
Character * Portrait_Last_Talker;
int Portrait_View;
int Portrait_Loop;
int Portrait_Frame;
int Portrait_Counter;
DynamicSprite *Portrait_Mod;
ViewFrame *Portrait_vf;
int Portrait_AnimSpeed;
int Portrait_BlinkTimer;
int Portrait_BlinkView;
int Portrait_BlinkLoop;
int Portrait_BlinkFrame;
int Portrait_BlinkInterval;
bool Portrait_AutoFlip;
int positioning;



function Portrait_DoFrame(GUI* Portrait_GUI) {
    Portrait_vf=Game.GetViewFrame(Portrait_View,  Portrait_Loop, Portrait_Frame);
    bool flip=Portrait_vf.Flipped;
    // Something like:
    if (Portrait_AutoFlip && Portrait_AtRight) flip=!flip;
    Portrait_Mod=DynamicSprite.CreateFromExistingSprite(Portrait_vf.Graphic, true);
    if (Portrait_BlinkTimer==0) {
      DrawingSurface *mod=Portrait_Mod.GetDrawingSurface();
      ViewFrame *bvf=Game.GetViewFrame(Portrait_BlinkView,  Portrait_BlinkLoop, Portrait_BlinkFrame);
      mod.DrawImage(0, 0, bvf.Graphic);
      mod.Release();
      Portrait_BlinkFrame++;
      if (Portrait_BlinkFrame==Game.GetFrameCountForLoop(Portrait_BlinkView,  Portrait_BlinkLoop)) {
        Portrait_BlinkTimer=Portrait_BlinkInterval;
        Portrait_BlinkFrame=0;
      }
    }
    // Flip AFTER blink, if required
    if (flip) Portrait_Mod.Flip(eFlipLeftToRight);
    Portrait_GUI.BackgroundGraphic=Portrait_Mod.Graphic;
}

void PortraitSay_Before(Character* acharacter, GUI* Portrait_GUI) {
  int view = -1;
  int loop = 0;
  if (view<1) view=acharacter.SpeechView;
  Portrait_Frame=0;
  Portrait_Loop=loop;
  Portrait_View=view;
  Portrait_AnimSpeed=acharacter.AnimationSpeed;
  positioning=GetGameOption(OPT_PORTRAITPOSITION);
  int x;
  if (positioning==0) { //Left
    Portrait_AtRight=false;
  } else if (positioning==1) { //Right
    Portrait_AtRight=true;
  } else if (positioning==2) { //Alternate
    if (acharacter!=Portrait_Last_Talker) Portrait_AtRight=!Portrait_AtRight;
  } else { // X positioning
    if (Portrait_Last_Talker != null && acharacter!=Portrait_Last_Talker) {
      Portrait_AtRight=acharacter.x>Portrait_Last_Talker.x;
    } else {
      // Cunning algorithm that one might prefer: count how many people
      // are on each side of us...
      //int side;
      //int j=0;
      //while (j<Game.CharacterCount) {
      //  if (character[j].Room==player.Room) {
      //    if (character[j].x<player.x) side++;
      //    else if (character[j].x>player.x) side--;
      //	}
      //	j++;
      //}
      //if (side>0) Portrait_AtRight=true;
      //else if (side<0) Portrait_AtRight=false;
      //else {
      //  if (acharacter!=Portrait_Last_Talker) Portrait_AtRight=!Portrait_AtRight;
      //}

      if (Portrait_Last_Talker != null && acharacter==Portrait_Last_Talker) {
        //Portrait_AtRight=!Portrait_AtRight;
      } else {
        if (acharacter.x<(Screen.Width/2)) Portrait_AtRight=false;
        else Portrait_AtRight=true;
      }

    }
  }

  Portrait_Last_Talker = acharacter;
  Portrait_DoFrame(Portrait_GUI);

  if (Portrait_AtRight) {
    x=Screen.Width-Game.SpriteWidth[Portrait_vf.Graphic]-Portrait_Right_Indent;
  } else {
    x=Portrait_Left_Indent;
  }

  Portrait_GUI.X=x;
  Portrait_GUI.Y=Portrait_Sierra_Y;
  SetGameOption(OPT_PORTRAITPOSITION, Portrait_AtRight);
  Portrait_GUI.Visible=true;
  Portrait_Counter=Portrait_AnimSpeed+Portrait_vf.Speed+1;
  if (acharacter.BlinkView>0) {
    Portrait_BlinkTimer=acharacter.BlinkInterval;
    Portrait_BlinkInterval=acharacter.BlinkInterval;
    Portrait_BlinkView=acharacter.BlinkView;
    Portrait_BlinkLoop=0;
    Portrait_BlinkFrame=0;
  }

  else Portrait_BlinkTimer=-1;
}

void PortraitSay_After(GUI * Portrait_GUI){
  Portrait_GUI.Visible=false;
  SetGameOption(OPT_PORTRAITPOSITION, positioning);
  Portrait_Counter=-1;
  Portrait_BlinkTimer=-1;
}

// Change this function to call a different Say() function
void SB_sayImpl(this Character*, String message)
{
  this.Say(message);
}

// If you want to use another function to animate background speech (e.g. to do lip-sync),
// call it here and return true
bool SB_sayBackgroundAnimateImpl(this Character*, String message)
{
  return false;
}

// If you're using another function to animate background speech, replace this with the
// appropriate test to see if the background speech animation is running
/*
bool SB_isSpeakingBackground(this Character*)
{
  SierraSpeech* sb = this.GetSierraSpeech();
  return (sb != null && sb.IsBackgroundSpeech);
}*/

#region Block functions
#define eMouseNone 0

enum BlockEndType
{
  eBlockTimeOut,
  eBlockKeyInterrupt,
  eBlockMouseInterrupt,
  eBlockUnknownInterrupt
};

//#define MAX_WAIT 32767
#define MAX_WAIT 20

#define CTRL_OFFSET 64
#define ALT_OFFSET (-236)
#define CTRL_RANGE_START 1
#define CTRL_RANGE_END 26
#define ALT_RANGE_START 301
#define ALT_RANGE_END 326
#define MAX_KEYCODE 435

#define eKeyLeftShift 403
#define eKeyRightShift 404
#define eKeyLeftCtrl 405
#define eKeyRightCtrl 406
#define eKeyLeftAlt 407
#define eKeyRightAlt 420

int _waitLoops;
eKeyCode _interruptKey;
MouseButton _interruptButton;

bool _wasButtonDown;
bool _wasKeyDown;

int _maxInt(int a, int b)
{
  if(a>b) return a;
  return b;
}

int _minInt(int a, int b)
{
  if(a<b) return a;
  return b;
}

bool IsButtonDownAny(static Mouse)
{
  return Mouse.IsButtonDown(eMouseLeft) || Mouse.IsButtonDown(eMouseRight) || Mouse.IsButtonDown(eMouseMiddle);
}

bool IsKeyPressedCombi(eKeyCode keyCode)
{
  if(keyCode >= CTRL_RANGE_START && keyCode <= CTRL_RANGE_END)
  {
    return (IsKeyPressed(eKeyLeftCtrl) || IsKeyPressed(eKeyRightCtrl)) && IsKeyPressed(keyCode+CTRL_OFFSET);
  }
  else if(keyCode >= ALT_RANGE_START && keyCode <= ALT_RANGE_END)
  {
    return (IsKeyPressed(eKeyLeftAlt) || IsKeyPressed(eKeyRightAlt)) && IsKeyPressed(keyCode+ALT_OFFSET);
  }
  else
    return IsKeyPressed(keyCode);
}

bool IsModifier(eKeyCode keyCode)
{
  return (keyCode == eKeyLeftShift || keyCode == eKeyRightShift ||
          keyCode == eKeyLeftCtrl  || keyCode == eKeyRightCtrl  ||
          keyCode == eKeyLeftAlt   || keyCode == eKeyRightAlt);
}

eKeyCode GetKeyPressed()
{
  for(int i=1; i<MAX_KEYCODE; i++)
  {
    if(!IsModifier(i) && IsKeyPressed(i))
      return i;
  }
  return 0;
}

bool IsKeyPressedAny()
{
  return (GetKeyPressed() != 0);
}

bool CheckKey(eKeyCode keyCode)
{
  if(keyCode == eKeyNone)
    return IsKeyPressedAny();
  else
    return IsKeyPressedCombi(keyCode);
}

bool CheckMouse(MouseButton button)
{
  if(button == eMouseNone)
    return Mouse.IsButtonDownAny();
  else
    return Mouse.IsButtonDown(button);
}

BlockEndType EndBlock(BlockEndType endType)
{
  _waitLoops = 0;
  _wasButtonDown = false;
  _wasKeyDown = false;
  return endType;
}

BlockEndType Block(int loops)
{
  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    Wait(_waitLoops);
  }
  return eBlockTimeOut;
}

BlockEndType BlockKey(int loops, eKeyCode keyCode)
{
  _interruptKey = keyCode;
  if(loops<0)
  {
    // Keep waiting indefinitely until the WaitKey() was interrupted
    while(true)
    {
      _waitLoops = MAX_WAIT;
      WaitKey(MAX_WAIT);
      // If the wrong key, ignore the interruption
      if((keyCode == eKeyNone && _waitLoops != 0) || IsKeyPressedCombi(keyCode) || _wasKeyDown)
        return EndBlock(eBlockKeyInterrupt);
    }
  }

  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    WaitKey(_waitLoops);
    if((keyCode == eKeyNone && _waitLoops != 0) || IsKeyPressedCombi(keyCode) || _wasKeyDown)
      return EndBlock(eBlockKeyInterrupt);
    loops += _waitLoops;
  }
  return EndBlock(eBlockTimeOut);
}

BlockEndType BlockMouse(int loops, MouseButton button)
{
  _interruptButton = button;
  if(loops<0)
  {
    while(true)
    {
      _waitLoops = MAX_WAIT;
      WaitMouseKey(MAX_WAIT);
      if(CheckMouse(button) || _wasButtonDown)
        return EndBlock(eBlockMouseInterrupt);
    }
  }

  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    WaitMouseKey(_waitLoops);
    if(CheckMouse(button) || _wasButtonDown)
      return EndBlock(eBlockMouseInterrupt);
    loops += _waitLoops;
  }
  return EndBlock(eBlockTimeOut);
}

BlockEndType BlockMouseKey(int loops, eKeyCode keyCode, MouseButton button)
{
  _interruptKey = keyCode;
  _interruptButton = button;
  if(loops<0)
  {
    // Keep waiting indefinitely until the WaitKey() was interrupted
    while(true)
    {
      _waitLoops = MAX_WAIT;
      WaitMouseKey(MAX_WAIT);
      if(CheckMouse(button) || _wasButtonDown)
        return EndBlock(eBlockMouseInterrupt);
      if(CheckKey(keyCode) || _wasKeyDown)
        return EndBlock(eBlockKeyInterrupt);
      // Fallback if we can't identify what was pressed, but it doesn't matter
      if(_waitLoops != 0 && button == eMouseNone && keyCode == eKeyNone)
        return EndBlock(eBlockUnknownInterrupt);
    }
  }

  while(loops>0)
  {
    _waitLoops = _minInt(MAX_WAIT, loops);
    loops -= _waitLoops;
    WaitMouseKey(_waitLoops);
    if(CheckMouse(button) || _wasButtonDown)
      return EndBlock(eBlockMouseInterrupt);
    if(CheckKey(keyCode) || _wasKeyDown)
      return EndBlock(eBlockKeyInterrupt);
    // Fallback if we can't identify what was pressed, but it doesn't matter
    if(_waitLoops != 0 && button == eMouseNone && keyCode == eKeyNone)
      return EndBlock(eBlockUnknownInterrupt);
    loops += _waitLoops;
  }
  return EndBlock(eBlockTimeOut);
}

BlockEndType BlockSpeech(int loops, bool forceTimeOut)
{
  switch(Speech.SkipStyle)
  {
    case eSkipKey:
      if(forceTimeOut)
        return BlockKey(loops, Speech.SkipKey);
      else
        return BlockKey(-1, Speech.SkipKey);
    case eSkipKeyMouse:
      if(forceTimeOut)
        return BlockMouseKey(loops, Speech.SkipKey, eMouseNone);
      else
        return BlockMouseKey(-1, Speech.SkipKey, eMouseNone);
    case eSkipKeyMouseTime:
      return BlockMouseKey(loops, Speech.SkipKey, eMouseNone);
    case eSkipKeyTime:
      return BlockKey(loops, Speech.SkipKey);
    case eSkipMouse:
      if(forceTimeOut)
        return BlockMouse(loops, eMouseNone);
      else
        return BlockMouse(-1, eMouseNone);
    case eSkipMouseTime:
      return BlockMouse(loops, eMouseNone);
    case -1: // In AGS 3.4.0, Speech.SkipStyle reports -1 instead of eSkipTime(==2) when set to that value
    case eSkipTime:
      return Block(loops);
  }
}

// called from repeatedly_execute_always()
function _block_always()
{
  if(_waitLoops != 0)
  {
    _wasButtonDown = CheckMouse(_interruptButton);
    _wasKeyDown = CheckKey(_interruptKey);
  }
  if(_waitLoops > 0)
    _waitLoops--;
}

#endregion

#region Variable declarations
// Variables for the SpeecSierra attributes
GUI* _defaultGui;
GUI* _defaultPortraitGui;

int _textOutlineColor;
int _textOutlineSpeechTint;
int _textOutlineWidth;
TextOutlineStyle _textOutlineStyle;

int _maxTextWidth;
int _heightOverHead;
int _paddingTop;
int _paddingBottom;
int _paddingLeft;
int _paddingRight;

GUI* _sierraGui;
FontType _invisibleFont;
Alignment _textAlign;

// Internal script variables
Character* _sierraChars[];
SierraSpeech* _charSierraBoxes[];  // Array to store sierras for all characters
String _sierraMessages[];
DynamicSprite* _sierraSprites[];
GUI* _sierraGuis[];
GUI* _sierraPortraitGuis[];
int _sierraCount;

#endregion

// Helper functions

int _clampInt(int value, int minRange, int maxRange)
{
  if(value<minRange) return minRange;
  if(value>maxRange) return maxRange;
  return value;
}

// Calculate the color that comes closest to a mix of c1 and c2 (at 'mix' percent c1)
int mixColors(int c1, int c2, int mix)
{
  if(mix==0) return c2;
  if(mix==100) return c1;
  int r1, g1, b1;
  int r2, g2, b2;

  // Extract the c1 channels
  if(c1 < 32)
  {
    r1 = (palette[c1].r << 2) + (palette[c1].r >> 4);
    g1 = (palette[c1].g << 2) + (palette[c1].g >> 4);
    b1 = (palette[c1].b << 2) + (palette[c1].b >> 4);
  }
  else
  {
    r1 = (c1 & 63488) >> 11; // 63488 = binary 11111-000000-00000
    g1 = (c1 & 2016) >> 5;   //  2016 = binary 00000-111111-00000
    b1 = (c1 & 31);          //    31 = binary 00000-000000-11111

    r1 = (r1 << 3) + (r1 >> 2);
    g1 = (g1 << 2) + (g1 >> 4);
    b1 = (b1 << 3) + (b1 >> 2);
  }

  // Extract the c2 channels
  if(c2 < 32)
  {
    r2 = (palette[c2].r << 2) + (palette[c2].r >> 4);
    g2 = (palette[c2].g << 2) + (palette[c2].g >> 4);
    b2 = (palette[c2].b << 2) + (palette[c2].b >> 4);
  }
  else
  {
    r2 = (c2 & 63488) >> 11; // 63488 = binary 11111-000000-00000
    g2 = (c2 & 2016) >> 5;   //  2016 = binary 00000-111111-00000
    b2 = (c2 & 31);          //    31 = binary 00000-000000-11111

    r2 = (r2 << 3) + (r2 >> 2);
    g2 = (g2 << 2) + (g2 >> 4);
    b2 = (b2 << 3) + (b2 >> 2);
  }

  // Calculate the mix
  int r = (r1 * mix + r2*(100-mix) + 50) / 100; // +50 to round up to nearest
  int g = (g1 * mix + g2*(100-mix) + 50) / 100;
  int b = (b1 * mix + b2*(100-mix) + 50) / 100;

  // Convert back to AGS color num
  r = r >> 3;
  g = g >> 2;
  b = b >> 3;

  r = r << 11;
  g = g << 5;

  int c = r+g+b;
  if(c < 32)
    c += 65536;
  return c;
}

// Attribute accessors
#region SierraSpeech Attribute accessors

#region static accessors
GUI* get_DefaultGui(static SierraSpeech)
{ return _defaultGui; }
void set_DefaultGui(static SierraSpeech, GUI* value)
{ _defaultGui = value; 
  _defaultGui.Visible = false;}


GUI* get_DefaultPortraitGui(static SierraSpeech)
{ return _defaultPortraitGui; }
void set_DefaultPortraitGui(static SierraSpeech, GUI* value)
{ _defaultPortraitGui = value;
  _defaultPortraitGui.Visible = false; }

int get_TextOutlineColor(static SierraSpeech)
{ return _textOutlineColor; }
void set_TextOutlineColor(static SierraSpeech, int value)
{ _textOutlineColor = value; }

int get_TextOutlineSpeechTint(static SierraSpeech)
{ return _textOutlineSpeechTint; }
void set_TextOutlineSpeechTint(static SierraSpeech, int value)
{ _textOutlineSpeechTint = _clampInt(value, 0, 100); }

int get_TextOutlineWidth(static SierraSpeech)
{ return _textOutlineWidth; }
void set_TextOutlineWidth(static SierraSpeech, int value)
{ _textOutlineWidth = value; }

TextOutlineStyle get_TextOutlineStyle(static SierraSpeech)
{ return _textOutlineStyle; }
void set_TextOutlineStyle(static SierraSpeech, TextOutlineStyle value)
{ _textOutlineStyle = value; }

int get_MaxTextWidth(static SierraSpeech)
{ return _maxTextWidth; }
void set_MaxTextWidth(static SierraSpeech, int value)
{ _maxTextWidth = value; }

int get_HeightOverHead(static SierraSpeech)
{ return _heightOverHead; }
void set_HeightOverHead(static SierraSpeech, int value)
{ _heightOverHead = value; }

int get_PaddingTop(static SierraSpeech)
{ return _paddingTop; }
void set_PaddingTop(static SierraSpeech, int value)
{ _paddingTop = value; }

int get_PaddingBottom(static SierraSpeech)
{ return _paddingBottom; }
void set_PaddingBottom(static SierraSpeech, int value)
{ _paddingBottom = value; }

int get_PaddingLeft(static SierraSpeech)
{ return _paddingLeft; }
void set_PaddingLeft(static SierraSpeech, int value)
{ _paddingLeft = value; }

int get_PaddingRight(static SierraSpeech)
{ return _paddingRight; }
void set_PaddingRight(static SierraSpeech, int value)
{ _paddingRight = value; }


FontType get_InvisibleFont(static SierraSpeech)
{ return _invisibleFont; }
void set_InvisibleFont(static SierraSpeech, FontType value)
{ _invisibleFont = value; }

Alignment get_TextAlign(static SierraSpeech)
{ return _textAlign; }
void set_TextAlign(static SierraSpeech, Alignment value)
{ _textAlign = value; }
#endregion

#region instance accessors
Character* get_OwningCharacter(this SierraSpeech*)
{
  if(this._id == -1) return null;
  else return character[this._id];
}

bool get_Valid(this SierraSpeech*)
{ return this._valid; }
bool get_IsBackgroundSpeech(this SierraSpeech*)
{ return this._isBackgroundSpeech; }
bool get_IsThinking(this SierraSpeech*)
{ return this._isThinking; }
bool get_IsAnimating(this SierraSpeech*)
{ return this._isAnimating; }
String get_Text(this SierraSpeech*)
{ return _sierraMessages[this._id]; }
DynamicSprite* get_SierraSprite(this SierraSpeech*)
{ return _sierraSprites[this._id]; }
GUI* get_SierraGUI(this SierraSpeech*)
{ return _sierraGuis[this._id]; }
int get_TotalDuration(this SierraSpeech*)
{ return this._totalDuration; }
int get_ElapsedDuration(this SierraSpeech*)
{ return this._elapsedDuration; }

int get_X(this SierraSpeech*)
{ return this._x; }
void set_X(this SierraSpeech*, int value)
{
  this._x = value;
  if(!this._valid) return;

  GUI* g = this.get_SierraGUI();
  g.X = value;

}

int get_Y(this SierraSpeech*)
{ return this._y; }
int set_Y(this SierraSpeech*, int value)
{
  this._y = value;
  if(!this._valid) return;

  GUI* g = this.get_SierraGUI();
  g.Y = value;

}

#endregion

// "Protected" setters: used internally to setup SierraSpeech instances
void setOwningCharacter(this SierraSpeech*, Character* value)
{
  if(value == null)
    this._id = -1;
  else
    this._id = value.ID;
}
void setValid(this SierraSpeech*, bool value)
{ this._valid = value; }
void setBackgroundSpeech(this SierraSpeech*, bool value)
{ this._isBackgroundSpeech = value; }
void setThinking(this SierraSpeech*, bool value)
{ this._isThinking = value; }
void setAnimating(this SierraSpeech*, bool value)
{ this._isAnimating = value; }
void setTotalDuration(this SierraSpeech*, int value)
{ this._totalDuration = value; }
void setElapsedDuration(this SierraSpeech*, int value)
{ this._elapsedDuration = value; }
void setX(this SierraSpeech*, int value)
{ this._x = value; }
void setY(this SierraSpeech*, int value)
{ this._y = value; }

SierraSpeech* Create(static SierraSpeech, Character* owner, String message, DynamicSprite* sierraSprite, GUI* sierraGui,  GUI* sierraPortraitGUI)
{
  SierraSpeech* sb = new SierraSpeech;
  sb.setOwningCharacter(owner);
  sb.setValid(true);
  int id = owner.ID;
  _charSierraBoxes[id] = sb;
  _sierraMessages[id] = message;
  _sierraSprites[id] = sierraSprite;
  _sierraGuis[id] = sierraGui;
  _sierraPortraitGuis[id] = sierraPortraitGUI;
  return sb;
}

void _addSierraChar(Character* c)
{
  _sierraChars[_sierraCount] = c;
  _sierraCount++;
}

bool _removeSierraChar(Character* c)
{
  if(c == null)
    return false;
  for(int i=0; i<_sierraCount; i++)
  {
    if(_sierraChars[i] == c)
    {
      _sierraCount--;
      _sierraChars[i] = _sierraChars[_sierraCount];
      _sierraChars[_sierraCount] = null;
      return true;
    }
  }
  return false;
}

void Remove(this SierraSpeech*)
{
  SierraSpeech* _this = this;
  int id = this._id;
  if(id != -1)
  {
    _removeSierraChar(this.get_OwningCharacter());

    _charSierraBoxes[id] = null;
    _sierraMessages[id] = null;
    if(_sierraSprites[id] != null)
      _sierraSprites[id].Delete();
    _sierraSprites[id] = null;
    if(_sierraGuis[id] != null)
      _sierraGuis[id].Visible = false;
    if(_sierraPortraitGuis[id] != null)
      _sierraPortraitGuis[id].Visible = false;
    _sierraGuis[id] = null;
    _sierraPortraitGuis[id] = null;
  }
  this._valid = false;
}


#endregion

// Calculate the height of the character at current scaling (due to rounding, believe this could be 1 pixel off)
int GetHeight(this Character*)
{
  ViewFrame* frame = Game.GetViewFrame(this.View, this.Loop, this.Frame);
  // TODO: Check that Z value is correctly calculated
  return ((Game.SpriteHeight[frame.Graphic] + this.z) * this.Scaling)/100;
}

// Whether the character is speaking in a speech sierra (if includeBackground, count background speech as speech)
bool IsSpeakingSierra(this Character*, bool includeBackground)
{
  SierraSpeech* sierra = _charSierraBoxes[this.ID];
  return (sierra != null && (includeBackground || !sierra.get_IsBackgroundSpeech()));
}

/// Interrupt the character if they are speaking in the background
bool StopBackgroundSierra(this Character*)
{
  SierraSpeech* sierra = _charSierraBoxes[this.ID];
  if(sierra != null && sierra.get_Valid() && sierra.get_IsBackgroundSpeech())
  {
    if(sierra.get_IsAnimating())
      this.UnlockView();
    sierra.Remove();
    return true;
  }
  return false;
}

void _stopAllBackgroundSierraBoxes()
{
  for(int i=_sierraCount-1; i >= 0; i--)
  {
    int id = _sierraChars[i].ID;
    if(_charSierraBoxes[id].get_IsBackgroundSpeech())
      _sierraChars[i].StopBackgroundSierra();
  }
}

/// The speech sierra used by the character (null if none)
SierraSpeech* GetSierraSpeech(this Character*)
{
  return _charSierraBoxes[this.ID];
}

// Initializations
void initSierraSpeech()
{
  // Initialize arrays
  _sierraChars = new Character[Game.CharacterCount];
  _charSierraBoxes = new SierraSpeech[Game.CharacterCount];
  _sierraMessages = new String[Game.CharacterCount];
  _sierraSprites = new DynamicSprite[Game.CharacterCount];
  _sierraGuis = new GUI[Game.CharacterCount];
  _sierraPortraitGuis = new GUI[Game.CharacterCount];

  // Set default values
  SierraSpeech.set_InvisibleFont(-1);
  SierraSpeech.set_TextAlign(eAlignCenter);

  SierraSpeech.set_MaxTextWidth(-1);
  SierraSpeech.set_TextOutlineColor(33);
  SierraSpeech.set_TextOutlineSpeechTint(10);
  SierraSpeech.set_TextOutlineWidth(1);
  SierraSpeech.set_TextOutlineStyle(eTextOutlineSquare);
  //SierraSpeech.set_PaddingTop(10);
  //SierraSpeech.set_PaddingBottom(10);
  //SierraSpeech.set_PaddingLeft(20);
  //SierraSpeech.set_PaddingRight(20);

  SierraSpeech.set_PaddingTop(6);
  SierraSpeech.set_PaddingBottom(6);
  SierraSpeech.set_PaddingLeft(6);
  SierraSpeech.set_PaddingRight(6);

  SierraSpeech.set_DefaultGui(gSierraTextBox);
  SierraSpeech.set_DefaultPortraitGui(gSierraPortrait);
}

function game_start()
{
  //stuff for portrait module
  Portrait_Sierra_Y=20; // Guess, seems lucky!
  Portrait_Left_Indent=10; // Trial and error
  Portrait_Right_Indent=5; // Trial and error
  Portrait_Counter=-1;
  Portrait_BlinkTimer=-1;
  _defaultTextGUI = gui[game.speech_text_gui];
  initSierraSpeech();
}

// To work around the AGS bug where antialiasing "pokes holes" in semi-transparent canvases
void drawStringWrappedAA(this DrawingSurface*, int x, int y, int width, FontType font, Alignment alignment, String message)
{
  DynamicSprite* textSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* textSurface = textSprite.GetDrawingSurface();
  textSurface.DrawingColor = this.DrawingColor;
  textSurface.DrawStringWrapped(x, y, width, font, alignment, message);
  textSurface.Release();
  this.DrawImage(0, 0, textSprite.Graphic);
  textSprite.Delete();
}

// Draw a string with outline (make sure the canvas has at least outlineWidth pixels on each side of the string)
void drawStringWrappedOutline(this DrawingSurface*, int x, int y, int width, TextOutlineStyle outlineStyle, FontType font,  Alignment alignment, String message, int outlineColor, int outlineWidth)
{
  // This is what we draw on (because we might need to copy with transparency)
  DynamicSprite* outlineSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* outlineSurface = outlineSprite.GetDrawingSurface();

  // This holds multiple horizontal copies of the text
  // We copy it multiple times (shifted vertically) onto the outlineSprite to create the outline
  DynamicSprite* outlineStripSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* outlineStripSurface = outlineStripSprite.GetDrawingSurface();

  // This is our "text stamp" that we use to draw the outline, we copy it onto outlineStripSprite
  DynamicSprite* textSprite = DynamicSprite.Create(this.Width, this.Height, true);
  DrawingSurface* textSurface = textSprite.GetDrawingSurface();

  // Draw our text stamp
  textSurface.DrawingColor = outlineColor;
  textSurface.DrawStringWrapped(x, y, width, font, alignment, message);
  textSurface.Release();

  switch(outlineStyle)
  {
    case eTextOutlineRounded:
    {
      // Draw Circular outline
      int maxSquare = outlineWidth*outlineWidth+1; // Add 1 for rounding purposes, to avoid "pointy corners"
      int maxWidth = 0;
      outlineStripSurface.DrawImage(0, 0, textSprite.Graphic);
      // We loop from top and bottom to the middle, making the outline wider and wider, to form circular outline
      for(int i = outlineWidth; i > 0; i--)
      {
        // Here's the circular calculation...
        while(i*i + maxWidth*maxWidth <= maxSquare)
        {
          // Increase width of the outline if necessary
          maxWidth++;
          outlineStripSurface.DrawImage(-maxWidth, 0, textSprite.Graphic);
          outlineStripSurface.DrawImage(maxWidth, 0, textSprite.Graphic);
          outlineStripSurface.Release();
          outlineStripSurface = outlineStripSprite.GetDrawingSurface();
        }
        // Draw outline strip above and below
        outlineSurface.DrawImage(0, -i, outlineStripSprite.Graphic);
        outlineSurface.DrawImage(0, i, outlineStripSprite.Graphic);
      }
      // Finally the middle strip
      outlineSurface.DrawImage(0, 0, outlineStripSprite.Graphic);
      break;
    }
    case eTextOutlineSquare:
    {
      // Draw square block outline
      // Just draw the full outline width onto the strip
      for(int i = -outlineWidth; i <= outlineWidth; i++)
        outlineStripSurface.DrawImage(i, 0, textSprite.Graphic);
      outlineStripSurface.Release();
      // Draw the full outline height
      for(int j = -outlineWidth; j <= outlineWidth; j++)
        outlineSurface.DrawImage(0, j, outlineStripSprite.Graphic);
      break;
    }
  }
  textSprite.Delete();
  outlineStripSurface.Release();
  outlineStripSprite.Delete();

  /// Now draw the text itself on top of the outline
  outlineSurface.DrawingColor = this.DrawingColor;
  outlineSurface.drawStringWrappedAA(x, y, width, font, alignment, message);
  outlineSurface.Release();
  // ... And copy it onto our canvas
  this.DrawImage(0, 0, outlineSprite.Graphic);
  outlineSprite.Delete();
}

// Find the actual width of a text that has been linewrapped to maxTextWidth
int calculateExactTextWidth(String message, FontType font, int maxTextWidth, int maxHeight)
{
  // Binary search to find the minimum width, by trying the midpoint (rounding down)
  // between the smallest width we know to be working and the biggest we know to be too small,
  // until there's only a 1 pixel difference
  int cut = maxTextWidth;
  int height = maxHeight;
  while(cut>1)
  {
    cut = (cut+1) >> 1; // Subtract half as much as we tried last time, rounding up
    height = GetTextHeight(message, font, maxTextWidth-cut);
    if(height == maxHeight)
      maxTextWidth -= cut;
  }
  // ... one last time
  height = GetTextHeight(message, font, maxTextWidth-1);
  if(height == maxHeight)
    return maxTextWidth-1;
  else
    return maxTextWidth;
}

// AGS's formula for character speech width
int calculateDefaultTextWidth(Character* c)
{
  int w;
  ViewFrame * vf;
  if(c.SpeechView > 0){
    //vf of SpeechView is Sierra Portrait
    vf = Game.GetViewFrame(c.SpeechView, 0, 0);
  }

  if( vf == null){
    w = Screen.Width-Portrait_Left_Indent-Portrait_Right_Indent;
  } else {
    w = Screen.Width-Game.SpriteWidth[vf.Graphic]-Portrait_Left_Indent-Portrait_Right_Indent;
  }

  return w;
}

// Draw a speech sierra in 32-bit (using transparency)
DynamicSprite* renderSierra32(this Character*, String message, bool talkTail)
{
  ViewFrame * vf;
  if(this.SpeechView > 0){
    vf = Game.GetViewFrame(this.SpeechView, 0, 0);
  }

  // Calculate text dimensions
  int textWidth = _maxTextWidth;
  if(textWidth <= 0)
    textWidth = calculateDefaultTextWidth(this);
  textWidth = _minInt(textWidth, Screen.Width - _paddingLeft - _paddingRight-Game.SpriteWidth[vf.Graphic]-Portrait_Left_Indent-Portrait_Right_Indent);
  int textHeight = GetTextHeight(message, fontWithoutOutline(Game.SpeechFont), textWidth);
  textWidth = calculateExactTextWidth(message, fontWithoutOutline(Game.SpeechFont), textWidth, textHeight);

  // Calculate sierra dimensions
  int totalWidth = textWidth + _paddingLeft + _paddingRight;
  int sierraHeight = textHeight + _paddingTop + _paddingBottom;


  // Set up the canvases
  DynamicSprite* sierraSprite = DynamicSprite.Create(totalWidth, sierraHeight, true);
  DrawingSurface* sierraSurface = sierraSprite.GetDrawingSurface();
  //sierraSurface.Clear();
  
  Button* gc_edge0 = _defaultTextGUI.Controls[0].AsButton;
  Button* gc_edge1 = _defaultTextGUI.Controls[1].AsButton;
  Button* gc_edge2 = _defaultTextGUI.Controls[2].AsButton;
  Button* gc_edge3 = _defaultTextGUI.Controls[3].AsButton;
  Button* gc_edge4 = _defaultTextGUI.Controls[4].AsButton;
  Button* gc_edge5 = _defaultTextGUI.Controls[5].AsButton;
  Button* gc_edge6 = _defaultTextGUI.Controls[6].AsButton;
  Button* gc_edge7 = _defaultTextGUI.Controls[7].AsButton;

  //draw background
  sierraSurface.DrawImage(Game.SpriteWidth[gc_edge0.NormalGraphic], Game.SpriteHeight[gc_edge0.NormalGraphic],
                      _defaultTextGUI.BackgroundGraphic, 0,
                      totalWidth-Game.SpriteWidth[gc_edge0.NormalGraphic]-Game.SpriteWidth[gc_edge3.NormalGraphic], sierraHeight-Game.SpriteHeight[gc_edge0.NormalGraphic]-Game.SpriteHeight[gc_edge3.NormalGraphic]);

  // Top Left Corner
  sierraSurface.DrawImage(0, 0, gc_edge0.NormalGraphic);


  // Top Right Corner
  sierraSurface.DrawImage(totalWidth-Game.SpriteWidth[gc_edge2.NormalGraphic], 0, gc_edge2.NormalGraphic);


  // Bottom Left Corner
  sierraSurface.DrawImage(0, sierraHeight-Game.SpriteHeight[gc_edge1.NormalGraphic],  gc_edge1.NormalGraphic);


  // Bottom Right Corner
  sierraSurface.DrawImage(totalWidth-Game.SpriteWidth[gc_edge3.NormalGraphic], sierraHeight-Game.SpriteHeight[gc_edge3.NormalGraphic], gc_edge3.NormalGraphic);

  // Top Edge
  sierraSurface.DrawImage(Game.SpriteWidth[gc_edge0.NormalGraphic], 0,
                      gc_edge6.NormalGraphic, 0,
                      totalWidth-Game.SpriteWidth[gc_edge0.NormalGraphic]-Game.SpriteWidth[gc_edge2.NormalGraphic], Game.SpriteHeight[gc_edge6.NormalGraphic]);
  // Left Edge
  sierraSurface.DrawImage(0, Game.SpriteHeight[gc_edge0.NormalGraphic],
                      gc_edge4.NormalGraphic, 0,
                      Game.SpriteWidth[gc_edge4.NormalGraphic], sierraHeight-Game.SpriteHeight[gc_edge0.NormalGraphic]-Game.SpriteHeight[gc_edge1.NormalGraphic]);
  // Right Edge
  sierraSurface.DrawImage(totalWidth-Game.SpriteWidth[gc_edge5.NormalGraphic], Game.SpriteHeight[gc_edge2.NormalGraphic],
                      gc_edge5.NormalGraphic, 0,
                      Game.SpriteWidth[gc_edge5.NormalGraphic], sierraHeight-Game.SpriteHeight[gc_edge2.NormalGraphic]-Game.SpriteHeight[gc_edge3.NormalGraphic]);

  // Bottom Edge
  sierraSurface.DrawImage(Game.SpriteWidth[gc_edge1.NormalGraphic], sierraHeight-Game.SpriteHeight[gc_edge7.NormalGraphic],
                      gc_edge7.NormalGraphic, 0,
                      totalWidth-Game.SpriteWidth[gc_edge1.NormalGraphic]-Game.SpriteWidth[gc_edge3.NormalGraphic], Game.SpriteHeight[gc_edge7.NormalGraphic]);


  sierraSurface.DrawingColor = this.SpeechColor;
  int outlineColor = mixColors(this.SpeechColor, _textOutlineColor, _textOutlineSpeechTint);
  if(_textOutlineWidth > 0)
    sierraSurface.drawStringWrappedOutline(_paddingLeft, _paddingTop, textWidth, _textOutlineStyle, fontWithoutOutline(Game.SpeechFont), _textAlign, message, outlineColor, _textOutlineWidth);
  else
    sierraSurface.drawStringWrappedAA(_paddingLeft, _paddingTop, textWidth, fontWithoutOutline(Game.SpeechFont), _textAlign, message);

  sierraSurface.Release();
  return sierraSprite;
}

// Whether a speech string has a voice clip ID
bool hasVoiceClip(String message)
{
  return (message != null && message.Length>1 && message.Chars[0] == '&' && message.Chars[1] >= '0' && message.Chars[1] <= '9');
}

// Get the voice clip ID (speech line number) of a speech string, in the "&123" string format
String getLineNumber(String message)
{
  if(hasVoiceClip(message))
  {
    String s = message.Substring(1, message.Length-1);
    int n = s.AsInt;
    return String.Format("&%d", n);
  }
  return null;
}

int calculateDuration(String message)
{
  return _maxInt((Game.MinimumTextDisplayTimeMs * GetGameSpeed()) / 1000,
                ((message.Length / Game.TextReadingSpeed) + 1) * GetGameSpeed());
}

int calculateSpeechPause()
{
  return (Speech.DisplayPostTimeMs * GetGameSpeed())/1000;
}

// Run the character's speech animation and block for the appropriate time. Returns whether interrupted
// is actually doing the blocking and not animation
bool BlockForSpeech(this Character*, String message)
{
  int speechDuration = calculateDuration(message);
  if(BlockSpeech(speechDuration, true) == eBlockTimeOut)
  {
    int speechPause = calculateSpeechPause();
    return (BlockSpeech(speechPause, false) != eBlockTimeOut);
  }
  else
  {
    return false;
  }
}

void realSayAtSierra(this Character*, int x, int y, String message, GUI* sierraGui, DynamicSprite* sierraSprite, GUI* sierraPortraitGui)
{
  // Render and display the speech sierra
  if(sierraSprite == null)
    sierraSprite = this.renderSierra32(message, true);

  if(sierraGui == null){
    sierraGui = _defaultGui;
  }
  if(sierraPortraitGui == null){
    sierraPortraitGui = _defaultPortraitGui;
  }

  sierraGui.Clickable = false;
  sierraGui.X = _clampInt(x, 0, Screen.Width - sierraSprite.Width);
  sierraGui.Y = _clampInt(y, 0, Screen.Height - sierraSprite.Height);
  sierraGui.Width = sierraSprite.Width;
  sierraGui.Height = sierraSprite.Height;
  sierraGui.BackgroundGraphic = sierraSprite.Graphic;
  sierraGui.Visible = true;

  SierraSpeech* sierra = SierraSpeech.Create(this, message, sierraSprite, sierraGui, sierraPortraitGui);

  sierra.setX(x);
  sierra.setY(y);
  sierra.setBackgroundSpeech(false);
  sierra.setThinking(false);
  _addSierraChar(this);

  // Play speech (this chunk blocks until speech is complete)

  String lineNumber = getLineNumber(message);
  // If we have set an invisible font, just call Say() - or whatever custom Say() implementation we have
  if(SierraSpeech.get_InvisibleFont() != -1)
  {
    FontType speechFont = Game.SpeechFont;
    Game.SpeechFont = _invisibleFont;
    this.SB_sayImpl(message);
    Game.SpeechFont = speechFont;
  }
  // Else if we're going to play a voice clip, call Say() with the clip number and a blank line of text
  // (takes care of animation and doesn't display any text). This doesn't work with text-based lip-sync,
  // so if you're using text-based lip-sync, you MUST set an invisible font to get lip-sync to work
  else if(lineNumber != null && Speech.VoiceMode != eSpeechTextOnly) // && !GetGameOption(OPT_LIPSYNCTEXT))
  {
    String s = lineNumber;
    while(s.Length < message.Length)
      s = s.AppendChar(' ');
    this.SB_sayImpl(s);
  }
  // Otherwise we have to do it manually...
  else
  {
    sierra.setAnimating(true);
    this.BlockForSpeech(message);
  }

  // Remove the sierra
  sierra.Remove();
}

void SierraSay(this Character*, String message, GUI* sierraGui,  GUI* sierraPortraitGui)
{
  if(message == null) return;
  if(!game.bgspeech_stay_on_display)
    _stopAllBackgroundSierraBoxes();
  if(sierraGui == null){
    sierraGui = _defaultGui;
  }
  if(sierraPortraitGui == null){
    sierraPortraitGui = _defaultPortraitGui;
  }
  if((Speech.VoiceMode == eSpeechVoiceOnly && hasVoiceClip(message)) || message == "...")
    this.SB_sayImpl(message);
  else
  {
    PortraitSay_Before(this, sierraPortraitGui);
    DynamicSprite* sierraSprite = this.renderSierra32(message, true);
    // Position sierra over character head
    int x = sierraSprite.Width/2;
    if (Portrait_AtRight) {
      x=Screen.Width-Game.SpriteWidth[Portrait_vf.Graphic]-Portrait_Right_Indent-sierraSprite.Width;
    } else {
      x=Portrait_Left_Indent+Game.SpriteWidth[Portrait_vf.Graphic];
    }
    x = _clampInt(x, 0, Screen.Width - sierraSprite.Width);

    int y = Portrait_Sierra_Y;
    y = _clampInt(y, 0, Screen.Height - sierraSprite.Height);

    sierraGui.Transparency = 0;
    //sierraGui.TweenTransparency(0.1, 0, eEaseLinearTween, eNoBlockTween);
    this.realSayAtSierra(x, y, message, sierraGui, sierraSprite, sierraPortraitGui);
    PortraitSay_After(sierraPortraitGui);
  }
}

void SierraSayAt(this Character*, int x, int y, String message, GUI* sierraGui,  GUI* sierraPortraitGui)
{
  if(message == null) return;
  if(sierraGui == null){
    sierraGui = _defaultGui;
  }
  if(sierraPortraitGui == null){
    sierraPortraitGui = _defaultPortraitGui;
  }
  if(!game.bgspeech_stay_on_display)
    _stopAllBackgroundSierraBoxes();
  if((Speech.VoiceMode == eSpeechVoiceOnly && hasVoiceClip(message)) || message == "...")
    this.SB_sayImpl(message);
  else {
    PortraitSay_Before(this, sierraPortraitGui);
    this.realSayAtSierra(x, y, message, sierraGui, null, sierraPortraitGui);
    PortraitSay_After(sierraPortraitGui);
  }
}

SierraSpeech* SierraSayBackground(this Character*, String message, bool animate, GUI* sierraGui,  GUI* sierraPortraitGui)
{
  if(message == null)
    return null;
  if(sierraGui == null){
    sierraGui = _defaultGui;
  }
  if(sierraPortraitGui == null){
    sierraPortraitGui = _defaultPortraitGui;
  }

  this.StopBackgroundSierra();
  DynamicSprite* sierraSprite = this.renderSierra32(message, true);
  
  Camera* mainCamera = Game.Camera;
  
  int x = this.x - mainCamera.X - sierraSprite.Width/2;
  x = _clampInt(x, 0, Screen.Width - sierraSprite.Width);
  int y = this.y - mainCamera.Y - sierraSprite.Height - this.GetHeight() - (_heightOverHead + 1);
  y = _clampInt(y, 0, Screen.Height - sierraSprite.Height);

  sierraGui.Clickable = false;
  sierraGui.X = _clampInt(x, 0, Screen.Width  - sierraSprite.Width);
  sierraGui.Y = _clampInt(y, 0, Screen.Height - sierraSprite.Height);
  sierraGui.Width = sierraSprite.Width;
  sierraGui.Height = sierraSprite.Height;
  sierraGui.BackgroundGraphic = sierraSprite.Graphic;
  sierraGui.Visible = true;

  SierraSpeech* sierra = SierraSpeech.Create(this, message, sierraSprite, sierraGui, sierraPortraitGui);
  sierra.setX(x);
  sierra.setY(y);
  sierra.setBackgroundSpeech(true);
  sierra.setThinking(false);
  sierra.setTotalDuration(calculateDuration(message));
  sierra.setAnimating(animate);

  // Add to stack of running Speech SierraBoxes to update
  _addSierraChar(this);

  // The background speech is terminated in StopBackgroundSierra(), called from repeatedly_execute()
}

// TODO
void SierraThink(this Character*, String message, GUI* sierraGui, GUI* sierraPortraitGui)
{
}

function repeatedly_execute()
{
  int speechPause = calculateSpeechPause();
  // Update the time elapsed on running sierras, remove background sierras that have timed out
  for(int i=0; i<_sierraCount; i++)
  {
    int id = _sierraChars[i].ID;
    _charSierraBoxes[id].setElapsedDuration(_charSierraBoxes[id].get_ElapsedDuration() + 1);
    if(_charSierraBoxes[id].get_IsBackgroundSpeech() && _charSierraBoxes[id].get_ElapsedDuration() > _charSierraBoxes[id].get_TotalDuration())
    {
      // Add the post-display time
      if(speechPause > 0 && _charSierraBoxes[id].get_IsAnimating())
      {
        _sierraChars[i].UnlockView();
        _charSierraBoxes[id].setAnimating(false);
        _charSierraBoxes[id].setTotalDuration(speechPause);
        _charSierraBoxes[id].setElapsedDuration(0);
      }
      else
        _sierraChars[i].StopBackgroundSierra();
    }
  }
}

function repeatedly_execute_always()
{
  // portrait animation if needed
  if (Portrait_Counter==0) {
    Portrait_Frame++;
    if (Portrait_Frame==Game.GetFrameCountForLoop(Portrait_View, Portrait_Loop)) {
      Portrait_Frame=0;
    }
    
    for(int i=0; i<_sierraCount; i++)
    {
      int id = _sierraChars[i].ID;
      if(_sierraPortraitGuis[id]!=null){
        Portrait_DoFrame(_sierraPortraitGuis[id]);
      }
    }
    
    Portrait_Counter=Portrait_AnimSpeed+Portrait_vf.Speed+1;
  } else if (Portrait_Counter>=0) {
    Portrait_Counter--;
  }

  if (Portrait_BlinkTimer>0) {
    Portrait_BlinkTimer--;
  }
  //end of portrait animation if needed

  _block_always();
}

function on_event(EventType event, int Data){
  if(event == eEventLeaveRoom){
    if(_defaultPortraitGui!= null && _defaultPortraitGui.Visible){
      PortraitSay_After(_defaultPortraitGui);
    }
    if(_defaultGui!= null && _defaultGui.Visible){
      _defaultGui.Visible = false;
    }
  }
}
